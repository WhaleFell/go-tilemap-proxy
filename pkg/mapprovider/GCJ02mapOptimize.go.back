// GCJ02 coordinate tile map convert to WGS84 tile map with pixel-level correction (only for locations inside China)
// GCJ02 坐标系的瓦片地图转换为 WGS84 坐标系的瓦片地图，支持逐像素精确纠偏，仅对中国境内区域启用纠偏

package mapprovider

import (
	"bytes"
	"fmt"
	"go-map-proxy/pkg/request"
	"image"
	"image/png"
	"io"
	"math"
	"net/http"
	"strconv"
	"strings"
	"sync"
)

// 增加缓存以提升 WGS84 → GCJ02 坐标转换效率
// var coordCache sync.Map // key: int64(px<<16|py), value: [2]float64{lat, lon}

// Convert lon/lat to global pixel position at zoom level z
// 经纬度转像素坐标（用于全球瓦片坐标系）
func lonLatToPixelXY(lon, lat float64, z int) (px, py int) {
	scale := math.Pow(2, float64(z)) * 256
	x := (lon + 180.0) / 360.0
	siny := math.Sin(lat * math.Pi / 180.0)
	y := 0.5 - math.Log((1+siny)/(1-siny))/(4*math.Pi)
	px = int(x * scale)
	py = int(y * scale)
	return
}

// Convert global pixel position to lon/lat
// 像素坐标转经纬度（反变换）
func pixelXYToLonLat(px, py int, z int) (lon, lat float64) {
	scale := math.Pow(2, float64(z)) * 256
	x := float64(px) / scale
	y := float64(py) / scale
	lon = x*360.0 - 180.0
	n := math.Pi - 2.0*math.Pi*y
	lat = 180.0 / math.Pi * math.Atan(0.5*(math.Exp(n)-math.Exp(-n)))
	return
}

// 判断经纬度是否在中国大陆范围内
func isInChina(lat, lon float64) bool {
	return lon >= 72.004 && lon <= 137.8347 && lat >= 0.8293 && lat <= 55.8271
}

// WGS84 → GCJ02 坐标转换（高德/腾讯使用的火星坐标系）
func wgs84ToGCJ02(wgsLat, wgsLon float64) (gcjLat, gcjLon float64) {
	dLat := transformLat(wgsLon-105.0, wgsLat-35.0)
	dLon := transformLon(wgsLon-105.0, wgsLat-35.0)
	radLat := wgsLat / 180.0 * math.Pi
	magic := math.Sin(radLat)
	magic = 1 - 0.00669342162296594323*magic*magic
	sqrtMagic := math.Sqrt(magic)
	dLat = (dLat * 180.0) / ((6378245.0 * (1 - 0.00669342162296594323)) / (magic * sqrtMagic) * math.Pi)
	dLon = (dLon * 180.0) / (6378245.0 / sqrtMagic * math.Cos(radLat) * math.Pi)
	gcjLat = wgsLat + dLat
	gcjLon = wgsLon + dLon
	return
}

// 纬度偏移计算（用于 GCJ02 加密）
func transformLat(x, y float64) float64 {
	ret := -100.0 + 2.0*x + 3.0*y + 0.2*y*y + 0.1*x*y + 0.2*math.Sqrt(math.Abs(x))
	ret += (20.0*math.Sin(6.0*x*math.Pi) + 20.0*math.Sin(2.0*x*math.Pi)) * 2.0 / 3.0
	ret += (20.0*math.Sin(y*math.Pi) + 40.0*math.Sin(y/3.0*math.Pi)) * 2.0 / 3.0
	ret += (160.0*math.Sin(y/12.0*math.Pi) + 320*math.Sin(y*math.Pi/30.0)) * 2.0 / 3.0
	return ret
}

// 经度偏移计算（用于 GCJ02 加密）
func transformLon(x, y float64) float64 {
	ret := 300.0 + x + 2.0*y + 0.1*x*x + 0.1*x*y + 0.1*math.Sqrt(math.Abs(x))
	ret += (20.0*math.Sin(6.0*x*math.Pi) + 20.0*math.Sin(2.0*x*math.Pi)) * 2.0 / 3.0
	ret += (20.0*math.Sin(x*math.Pi) + 40.0*math.Sin(x/3.0*math.Pi)) * 2.0 / 3.0
	ret += (150.0*math.Sin(x/12.0*math.Pi) + 300.0*math.Sin(x/30.0*math.Pi)) * 2.0 / 3.0
	return ret
}

// 地图源配置结构体
// GCJ02MapProvider 表示一个使用 GCJ02 坐标系的地图提供器（如高德）
type GCJ02MapProvider struct {
	Name           string // 地图名称
	BaseURL        string // 地图 URL 模板
	ReferenceURL   string // 请求头中的 Referer
	CoordinateType string // 坐标类型标识（GCJ02）
}

// 获取地图名称
func (gcjmap *GCJ02MapProvider) GetMapName() string {
	return gcjmap.Name
}

// 获取地图瓦片图像，必要时执行像素级纠偏
func (gcjmap *GCJ02MapProvider) GetMapPic(x, y, z int) (*http.Response, error) {
	httpClient := request.DefaultHTTPClient

	// 判断整个瓦片是否完全不在中国，若是则直接获取原始瓦片
	wgsLonTopLeft, wgsLatTopLeft := pixelXYToLonLat(x*256, y*256, z)
	wgsLonBottomRight, wgsLatBottomRight := pixelXYToLonLat((x+1)*256-1, (y+1)*256-1, z)
	if !isInChina(wgsLatTopLeft, wgsLonTopLeft) && !isInChina(wgsLatBottomRight, wgsLonBottomRight) {
		url := strings.Replace(gcjmap.BaseURL, "{x}", strconv.Itoa(x), 1)
		url = strings.Replace(url, "{y}", strconv.Itoa(y), 1)
		url = strings.Replace(url, "{z}", strconv.Itoa(z), 1)
		req, _ := http.NewRequest(http.MethodGet, url, nil)
		req.Header.Set("User-Agent", request.DefaultUserAgent)
		if gcjmap.ReferenceURL != "" {
			req.Header.Set("Referer", gcjmap.ReferenceURL)
		}
		resp, err := httpClient.Do(req)
		if err != nil {
			return nil, err
		}
		return resp, nil
	}

	tile := image.NewRGBA(image.Rect(0, 0, 256, 256))
	sourceTileCache := sync.Map{} // 使用 sync.Map 并发安全缓存

	const MaxParallel = 2
	sem := make(chan struct{}, MaxParallel)

	var wg sync.WaitGroup
	var mu sync.Mutex // 用于保护 tile 的写操作
	for py := 0; py < 256; py++ {
		// py := py
		wg.Add(1)
		sem <- struct{}{} // acquire
		go func(py int) {
			defer func() {
				<-sem // release
				wg.Done()
			}()
			for px := 0; px < 256; px++ {
				// pxKey := int64(py)<<16 | int64(px)
				wgsLon, wgsLat := pixelXYToLonLat(x*256+px, y*256+py, z)
				if !isInChina(wgsLat, wgsLon) {
					continue
				}
				var gcjLat, gcjLon float64
				// if val, ok := coordCache.Load(pxKey); ok {
				// 	gcjLat = val.([2]float64)[0]
				// 	gcjLon = val.([2]float64)[1]
				// } else {
				gcjLat, gcjLon = wgs84ToGCJ02(wgsLat, wgsLon)
				// coordCache.Store(pxKey, [2]float64{gcjLat, gcjLon})
				// }
				gx, gy := lonLatToPixelXY(gcjLon, gcjLat, z)
				tx := gx / 256
				ty := gy / 256
				sx := gx % 256
				sy := gy % 256
				tileKey := fmt.Sprintf("%d_%d_%d", tx, ty, z)

				var srcTile image.Image
				if val, ok := sourceTileCache.Load(tileKey); ok {
					srcTile = val.(image.Image)
				} else {
					url := strings.Replace(gcjmap.BaseURL, "{x}", strconv.Itoa(tx), 1)
					url = strings.Replace(url, "{y}", strconv.Itoa(ty), 1)
					url = strings.Replace(url, "{z}", strconv.Itoa(z), 1)
					req, _ := http.NewRequest(http.MethodGet, url, nil)
					req.Header.Set("User-Agent", request.DefaultUserAgent)
					if gcjmap.ReferenceURL != "" {
						req.Header.Set("Referer", gcjmap.ReferenceURL)
					}
					resp, err := httpClient.Do(req)
					if err != nil || resp.StatusCode != http.StatusOK {
						continue
					}
					img, err := png.Decode(resp.Body)
					resp.Body.Close()
					if err != nil {
						continue
					}
					sourceTileCache.Store(tileKey, img)
					srcTile = img
				}

				if rgbaImg, ok := srcTile.(*image.RGBA); ok {
					if sx < 256 && sy < 256 {
						mu.Lock()
						color := rgbaImg.RGBAAt(sx, sy)
						tile.SetRGBA(px, py, color)
						mu.Unlock()
					}
				} else {
					mu.Lock()
					c := srcTile.At(sx, sy)
					tile.Set(px, py, c)
					mu.Unlock()
				}
			}
		}(py)
	}
	wg.Wait()

	var buf bytes.Buffer
	buf.Grow(256 * 256 * 4) // 提前分配缓冲区避免多次扩容
	_ = png.Encode(&buf, tile)
	return &http.Response{
		StatusCode: http.StatusOK,
		Body:       io.NopCloser(&buf),
		Header:     http.Header{"Content-Type": []string{"image/png"}},
	}, nil
}

// 高德路网地图提供器定义
var AmapRoadMap = &GCJ02MapProvider{
	Name:           "Amap Road Map 高德路网",
	BaseURL:        "https://webst01.is.autonavi.com/appmaptile?style=8&x={x}&y={y}&z={z}",
	ReferenceURL:   "https://www.amap.com/",
	CoordinateType: "GCJ02",
}
